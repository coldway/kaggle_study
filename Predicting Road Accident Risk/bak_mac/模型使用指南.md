# 模型使用指南

本文档介绍如何使用训练好的模型进行预测，包括单次预测、批量预测和HTTP服务。

## 目录

1. [模型训练和保存](#模型训练和保存)
2. [单次预测](#单次预测)
3. [批量预测](#批量预测)
4. [HTTP服务](#http服务)
5. [Docker部署HTTP服务](#docker部署http服务)
6. [API接口说明](#api接口说明)

## 模型训练和保存

### 训练模型

首先，需要训练模型并保存：

```bash
python3 road_accident_risk_mac.py \
    --data-dir ./playground-series-s5e10 \
    --output-dir ./output \
    --skip-install
```

训练完成后，模型会保存在 `./output/models/` 目录下，包含：
- `model_fold_1.pkl` 到 `model_fold_5.pkl`：5个fold的模型文件（每个fold的独立模型）
- `ensemble_model.pkl`：**集成模型包装器**（推荐使用，自动平均所有fold的预测结果）
- `metadata.json`：模型元数据（特征列表、参数等）

### 为什么需要保存所有fold的模型？

**重要说明**：深度学习模型（如TabM）的权重不能直接平均，因此我们采用**集成预测（Ensemble Prediction）**的方式：

1. **不能平均模型权重**：
   - 神经网络的权重是复杂的参数矩阵
   - 直接平均权重会导致模型性能下降甚至失效
   - 每个fold的模型在不同数据上训练，权重分布不同

2. **集成预测的优势**：
   - 每个fold的模型在验证集上表现不同
   - 通过平均**预测结果**而不是模型权重，可以获得更好的泛化性能
   - 这是机器学习中常用的集成方法（Ensemble Learning）

3. **集成模型包装器**：
   - `ensemble_model.pkl` 是一个包装器，内部包含所有fold的模型
   - 使用时就像单个模型一样：`ensemble_model.predict(X)`
   - 内部自动对所有fold的预测结果进行平均
   - 这样既保留了集成预测的优势，又提供了统一的接口

**文件说明**：
- **保留所有fold模型**：便于调试、分析单个fold的性能、或单独使用某个fold
- **集成模型包装器**：推荐用于生产环境，使用简单，性能更好

## 单次预测

### 使用JSON文件进行单次预测

创建输入文件 `input.json`：

```json
{
  "curvature": 0.5,
  "lighting": "day",
  "weather": "clear",
  "road_signs_present": "yes",
  "public_road": "yes",
  "time_of_day": "morning",
  "holiday": "no",
  "school_season": "yes",
  "speed_limit": 50,
  "num_reported_accidents": 2
}
```

运行预测：

```bash
python3 road_accident_risk_mac.py \
    --mode predict \
    --model-dir ./output/models \
    --input input.json \
    --output prediction.json
```

### 使用CSV文件进行批量预测

创建输入文件 `input.csv`：

```csv
curvature,lighting,weather,road_signs_present,public_road,time_of_day,holiday,school_season,speed_limit,num_reported_accidents
0.5,day,clear,yes,yes,morning,no,yes,50,2
0.8,night,rain,no,yes,evening,yes,no,60,5
```

运行预测：

```bash
python3 road_accident_risk_mac.py \
    --mode predict \
    --model-dir ./output/models \
    --input input.csv \
    --output predictions.csv \
    --orig-data-path ./playground-series-s5e10/synthetic_road_accidents_100k.csv
```

输出文件 `predictions.csv` 将包含原始数据和预测结果：

```csv
curvature,lighting,weather,...,prediction
0.5,day,clear,...,0.234
0.8,night,rain,...,0.567
```

## 批量预测

批量预测与单次预测使用相同的命令，只需在输入文件中包含多条记录即可。

### JSON格式（数组）

```json
[
  {
    "curvature": 0.5,
    "lighting": "day",
    "weather": "clear",
    ...
  },
  {
    "curvature": 0.8,
    "lighting": "night",
    "weather": "rain",
    ...
  }
]
```

### CSV格式

CSV格式天然支持批量数据，每行一条记录。

## HTTP服务

### 本地启动HTTP服务

```bash
python3 road_accident_risk_mac.py \
    --mode serve \
    --model-dir ./output/models \
    --host 0.0.0.0 \
    --port 5000 \
    --orig-data-path ./playground-series-s5e10/synthetic_road_accidents_100k.csv
```

服务启动后，可以通过以下接口访问：

- 健康检查：`http://localhost:5000/health`
- 预测接口：`http://localhost:5000/predict`
- 批量预测：`http://localhost:5000/predict/batch`
- 模型信息：`http://localhost:5000/model/info`

### 测试HTTP服务

#### 健康检查

```bash
curl http://localhost:5000/health
```

响应：
```json
{
  "status": "healthy",
  "model_loaded": true
}
```

#### 单次预测

```bash
curl -X POST http://localhost:5000/predict \
  -H "Content-Type: application/json" \
  -d '{
    "curvature": 0.5,
    "lighting": "day",
    "weather": "clear",
    "road_signs_present": "yes",
    "public_road": "yes",
    "time_of_day": "morning",
    "holiday": "no",
    "school_season": "yes",
    "speed_limit": 50,
    "num_reported_accidents": 2
  }'
```

响应：
```json
{
  "prediction": 0.234
}
```

#### 批量预测

```bash
curl -X POST http://localhost:5000/predict/batch \
  -H "Content-Type: application/json" \
  -d '[
    {
      "curvature": 0.5,
      "lighting": "day",
      "weather": "clear",
      "road_signs_present": "yes",
      "public_road": "yes",
      "time_of_day": "morning",
      "holiday": "no",
      "school_season": "yes",
      "speed_limit": 50,
      "num_reported_accidents": 2
    },
    {
      "curvature": 0.8,
      "lighting": "night",
      "weather": "rain",
      "road_signs_present": "no",
      "public_road": "yes",
      "time_of_day": "evening",
      "holiday": "yes",
      "school_season": "no",
      "speed_limit": 60,
      "num_reported_accidents": 5
    }
  ]'
```

响应：
```json
{
  "predictions": [0.234, 0.567]
}
```

#### 获取模型信息

```bash
curl http://localhost:5000/model/info
```

响应：
```json
{
  "n_folds": 5,
  "features": ["curvature", "lighting", "weather", ...],
  "n_features": 20,
  "target": "accident_risk"
}
```

## Docker部署HTTP服务

### 前置条件

1. 确保已经训练并保存了模型（`./output/models/` 目录存在）
2. 安装Docker和Docker Compose

### 使用Docker Compose启动服务

```bash
# 构建并启动服务
docker-compose -f docker-compose.api.yml up --build

# 后台运行
docker-compose -f docker-compose.api.yml up -d --build

# 查看日志
docker-compose -f docker-compose.api.yml logs -f

# 停止服务
docker-compose -f docker-compose.api.yml down
```

### 使用Docker命令启动服务

```bash
# 构建镜像
docker build -f Dockerfile.api -t road-accident-risk-api:latest .

# 运行容器
docker run -d \
  --name road-accident-risk-api \
  -p 5000:5000 \
  -v $(pwd)/output/models:/app/models:ro \
  -v $(pwd)/playground-series-s5e10:/app/data:ro \
  road-accident-risk-api:latest \
  python road_accident_risk_mac.py \
    --mode serve \
    --model-dir /app/models \
    --host 0.0.0.0 \
    --port 5000 \
    --orig-data-path /app/data/synthetic_road_accidents_100k.csv

# 查看日志
docker logs -f road-accident-risk-api

# 停止容器
docker stop road-accident-risk-api
docker rm road-accident-risk-api
```

### 验证Docker服务

```bash
# 健康检查
curl http://localhost:5000/health

# 测试预测
curl -X POST http://localhost:5000/predict \
  -H "Content-Type: application/json" \
  -d '{
    "curvature": 0.5,
    "lighting": "day",
    "weather": "clear",
    "road_signs_present": "yes",
    "public_road": "yes",
    "time_of_day": "morning",
    "holiday": "no",
    "school_season": "yes",
    "speed_limit": 50,
    "num_reported_accidents": 2
  }'
```

## API接口说明

### 1. 健康检查

**GET** `/health`

检查服务是否正常运行。

**响应示例：**
```json
{
  "status": "healthy",
  "model_loaded": true
}
```

### 2. 预测接口

**POST** `/predict`

支持单次和批量预测。如果请求体是对象，则进行单次预测；如果是数组，则进行批量预测。

**请求体（单次预测）：**
```json
{
  "curvature": 0.5,
  "lighting": "day",
  "weather": "clear",
  "road_signs_present": "yes",
  "public_road": "yes",
  "time_of_day": "morning",
  "holiday": "no",
  "school_season": "yes",
  "speed_limit": 50,
  "num_reported_accidents": 2
}
```

**响应（单次预测）：**
```json
{
  "prediction": 0.234
}
```

**请求体（批量预测）：**
```json
[
  { "curvature": 0.5, ... },
  { "curvature": 0.8, ... }
]
```

**响应（批量预测）：**
```json
{
  "predictions": [0.234, 0.567]
}
```

### 3. 批量预测接口

**POST** `/predict/batch`

专门用于批量预测的接口，请求体必须是数组格式。

**请求体：**
```json
[
  { "curvature": 0.5, ... },
  { "curvature": 0.8, ... }
]
```

**响应：**
```json
{
  "predictions": [0.234, 0.567]
}
```

### 4. 模型信息接口

**GET** `/model/info`

获取模型的基本信息。

**响应示例：**
```json
{
  "n_folds": 5,
  "features": ["curvature", "lighting", "weather", ...],
  "n_features": 20,
  "target": "accident_risk"
}
```

## 必需的特征字段

预测时需要提供以下所有特征字段：

- `curvature` (数值)
- `lighting` (分类: "day", "night", 等)
- `weather` (分类: "clear", "rain", 等)
- `road_signs_present` (分类: "yes", "no", 等)
- `public_road` (分类: "yes", "no", 等)
- `time_of_day` (分类: "morning", "afternoon", "evening", "night")
- `holiday` (分类: "yes", "no")
- `school_season` (分类: "yes", "no")
- `speed_limit` (数值)
- `num_reported_accidents` (数值)

## 注意事项

1. **原始数据文件**：如果训练时使用了原始数据文件（`synthetic_road_accidents_100k.csv`），预测时也需要提供该文件路径（通过 `--orig-data-path` 参数），以便进行特征工程。

2. **特征顺序**：输入数据的特征顺序不重要，但必须包含所有必需的特征。

3. **数据类型**：确保数值特征是数字类型，分类特征是字符串类型。

4. **模型路径**：确保模型目录包含所有fold的模型文件和元数据文件。推荐使用集成模型包装器（`ensemble_model.pkl`），代码会自动加载。

5. **集成模型 vs 单个模型**：
   - **推荐使用集成模型**：加载 `ensemble_model.pkl`，自动平均所有fold的预测结果，性能更好
   - **单个fold模型**：可以单独使用某个fold的模型，但性能通常不如集成模型

6. **端口冲突**：如果5000端口被占用，可以使用 `--port` 参数指定其他端口。

7. **Docker挂载**：使用Docker时，确保正确挂载模型目录和数据目录。

## 故障排除

### 问题1：模型文件不存在

**错误信息：**
```
FileNotFoundError: 模型文件不存在: ./output/models/model_fold_1.pkl
```

**解决方案：**
- 确保已经完成模型训练
- 检查模型目录路径是否正确
- 确认模型文件确实存在
- 如果只有 `ensemble_model.pkl`，代码会自动使用它（推荐方式）

### 问题2：缺少必需的特征

**错误信息：**
```
ValueError: 缺少必需的特征: {'curvature', 'lighting', ...}
```

**解决方案：**
- 检查输入数据是否包含所有必需的特征
- 确认特征名称拼写正确

### 问题3：HTTP服务无法启动

**错误信息：**
```
OSError: [Errno 48] Address already in use
```

**解决方案：**
- 检查端口是否被占用：`lsof -i :5000`
- 使用其他端口：`--port 5001`
- 停止占用端口的进程

### 问题4：Docker容器无法访问模型

**错误信息：**
```
FileNotFoundError: 元数据文件不存在: /app/models/metadata.json
```

**解决方案：**
- 检查Docker挂载路径是否正确
- 确认主机上的模型目录存在
- 检查文件权限

## 完整示例

### 示例1：训练模型并保存

```bash
# 1. 训练模型
python3 road_accident_risk_mac.py \
    --data-dir ./playground-series-s5e10 \
    --output-dir ./output \
    --skip-install

# 2. 验证模型已保存
ls -la ./output/models/
```

### 示例2：本地预测

```bash
# 创建测试数据
cat > test_data.json << EOF
{
  "curvature": 0.5,
  "lighting": "day",
  "weather": "clear",
  "road_signs_present": "yes",
  "public_road": "yes",
  "time_of_day": "morning",
  "holiday": "no",
  "school_season": "yes",
  "speed_limit": 50,
  "num_reported_accidents": 2
}
EOF

# 执行预测
python3 road_accident_risk_mac.py \
    --mode predict \
    --model-dir ./output/models \
    --input test_data.json \
    --output result.json
```

### 示例3：启动HTTP服务并使用

```bash
# 1. 启动服务（后台运行）
python3 road_accident_risk_mac.py \
    --mode serve \
    --model-dir ./output/models \
    --host 0.0.0.0 \
    --port 5000 &

# 2. 等待服务启动
sleep 5

# 3. 测试预测
curl -X POST http://localhost:5000/predict \
  -H "Content-Type: application/json" \
  -d @test_data.json

# 4. 停止服务
pkill -f "road_accident_risk_mac.py"
```

### 示例4：Docker部署

```bash
# 1. 构建并启动
docker-compose -f docker-compose.api.yml up -d --build

# 2. 等待服务启动
sleep 10

# 3. 测试
curl http://localhost:5000/health
curl -X POST http://localhost:5000/predict \
  -H "Content-Type: application/json" \
  -d @test_data.json

# 4. 停止
docker-compose -f docker-compose.api.yml down
```

## 总结

本文档介绍了模型的完整使用流程：

1. ✅ **训练和保存模型**：使用 `--mode train` 训练并自动保存模型
   - 保存所有fold的模型文件（便于调试和分析）
   - 自动创建集成模型包装器（推荐用于生产环境）
2. ✅ **单次预测**：使用 `--mode predict` 对单条数据进行预测
   - 自动使用集成模型（如果存在），自动平均所有fold的预测结果
3. ✅ **批量预测**：使用 `--mode predict` 对CSV或JSON数组进行批量预测
   - 支持批量处理，自动使用集成模型
4. ✅ **HTTP服务**：使用 `--mode serve` 启动HTTP服务
   - 自动加载集成模型，提供REST API接口
5. ✅ **Docker部署**：使用Docker容器部署HTTP服务
   - 支持健康检查和自动重启

### 关于模型保存的说明

**为什么保存所有fold的模型？**

- **深度学习模型不能平均权重**：神经网络的权重是复杂的参数矩阵，直接平均会导致性能下降
- **集成预测更有效**：通过平均**预测结果**而不是模型权重，可以获得更好的泛化性能
- **集成模型包装器**：`ensemble_model.pkl` 提供了统一的接口，使用起来像单个模型，但内部自动进行集成预测

**文件结构**：
```
./output/models/
├── model_fold_1.pkl      # Fold 1 的模型（保留，便于调试）
├── model_fold_2.pkl      # Fold 2 的模型
├── model_fold_3.pkl      # Fold 3 的模型
├── model_fold_4.pkl      # Fold 4 的模型
├── model_fold_5.pkl      # Fold 5 的模型
├── ensemble_model.pkl    # 集成模型包装器（推荐使用）⭐
└── metadata.json          # 模型元数据
```

所有功能都已集成在 `road_accident_risk_mac.py` 中，通过命令行参数切换不同的模式。

