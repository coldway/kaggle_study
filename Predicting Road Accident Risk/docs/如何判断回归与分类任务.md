# 如何判断回归任务与分类任务

## 📋 目录

1. [从当前项目判断回归任务](#从当前项目判断回归任务)
2. [回归 vs 分类：核心区别](#回归-vs-分类核心区别)
3. [判断方法：从数据入手](#判断方法从数据入手)
4. [判断方法：从目标变量入手](#判断方法从目标变量入手)
5. [判断方法：从评估指标入手](#判断方法从评估指标入手)
6. [判断方法：从模型选择入手](#判断方法从模型选择入手)
7. [实际案例对比](#实际案例对比)
8. [判断流程图](#判断流程图)
9. [特殊情况处理](#特殊情况处理)

---

## 从当前项目判断回归任务

### 判断依据

在"道路事故风险预测"项目中，以下证据表明这是**回归任务**：

#### 1. 目标变量的性质

```python
# 查看目标变量
train['accident_risk'].head()
# 输出：
# 0    0.13
# 1    0.35
# 2    0.30
# 3    0.21
# 4    0.42
```

**判断**：
- ✅ 目标变量是**连续数值**（0.13, 0.35, 0.30...）
- ✅ 数值范围在 [0, 1] 之间
- ✅ 可以有任意精度的小数

#### 2. 评估指标

```python
# 使用的评估指标
from sklearn.metrics import root_mean_squared_error
rmse = root_mean_squared_error(y_true, y_pred)
```

**判断**：
- ✅ 使用 **RMSE**（均方根误差）
- ✅ RMSE 是回归任务的标准指标
- ❌ 没有使用准确率、精确率、召回率等分类指标

#### 3. 模型类型

```python
# 使用的模型
from pytabkit import TabM_D_Regressor  # ← 注意是 Regressor（回归器）

model = TabM_D_Regressor(...)
```

**判断**：
- ✅ 使用 **Regressor**（回归器）
- ✅ 不是 Classifier（分类器）

#### 4. 输出格式

```python
# 预测输出
predictions = model.predict(X_test)
# 输出：连续数值，如 [0.13, 0.35, 0.28, ...]
```

**判断**：
- ✅ 输出是**连续数值**
- ✅ 不是离散的类别标签

---

## 回归 vs 分类：核心区别

### 核心区别表

| 特性 | 回归任务 | 分类任务 |
|------|---------|---------|
| **目标变量类型** | 连续数值 | 离散类别 |
| **输出** | 数值（可以是任意小数） | 类别标签（整数或字符串） |
| **预测目标** | 预测数值 | 预测类别 |
| **评估指标** | RMSE, MAE, R² | 准确率, 精确率, 召回率, F1 |
| **模型类型** | Regressor | Classifier |
| **损失函数** | MSE, MAE | 交叉熵, 对数损失 |
| **输出层** | 线性层（1个神经元） | Softmax/Sigmoid（多个神经元） |

### 直观理解

#### 回归任务
```
输入：房屋特征（面积、位置、房龄...）
输出：房价 = 500,000 元（连续数值）
```

#### 分类任务
```
输入：邮件内容
输出：类别 = "垃圾邮件" 或 "正常邮件"（离散类别）
```

---

## 判断方法：从数据入手

### 方法 1：查看目标变量的数据类型

```python
import pandas as pd
import numpy as np

# 加载数据
train = pd.read_csv('train.csv')

# 查看目标变量
target = train['target_column']

# 判断方法
print(f"目标变量类型: {target.dtype}")
print(f"唯一值数量: {target.nunique()}")
print(f"样本总数: {len(target)}")
print(f"唯一值比例: {target.nunique() / len(target):.2%}")
print(f"\n前10个值:")
print(target.head(10))
print(f"\n值分布:")
print(target.describe())
```

### 判断标准

#### 回归任务的标志 ✅

```python
# 示例 1：连续数值
target = [0.13, 0.35, 0.30, 0.21, 0.42, ...]
# 特征：
# - 唯一值数量 ≈ 样本数量（或很大比例）
# - 有小数部分
# - 数值范围连续
```

#### 分类任务的标志 ✅

```python
# 示例 2：离散类别
target = [0, 1, 0, 1, 1, 0, ...]  # 二分类
target = ['cat', 'dog', 'bird', ...]  # 多分类
# 特征：
# - 唯一值数量很少（2-100个）
# - 没有小数部分（或很少）
# - 数值是整数或字符串
```

### 实际代码示例

```python
def check_task_type(target_column):
    """
    检查任务类型
    
    Args:
        target_column: 目标变量（Series）
    
    Returns:
        'regression' 或 'classification'
    """
    # 基本统计
    n_unique = target_column.nunique()
    n_total = len(target_column)
    unique_ratio = n_unique / n_total
    
    # 数据类型
    dtype = target_column.dtype
    
    # 是否有小数部分
    if dtype in ['float64', 'float32']:
        has_decimals = (target_column % 1 != 0).any()
    else:
        has_decimals = False
    
    print("=" * 60)
    print("任务类型判断")
    print("=" * 60)
    print(f"目标变量类型: {dtype}")
    print(f"唯一值数量: {n_unique}")
    print(f"样本总数: {n_total}")
    print(f"唯一值比例: {unique_ratio:.2%}")
    print(f"是否有小数: {has_decimals}")
    print(f"\n值分布:")
    print(target_column.describe())
    print(f"\n前10个值:")
    print(target_column.head(10))
    
    # 判断逻辑
    if unique_ratio > 0.5 and has_decimals:
        # 唯一值比例高 + 有小数 → 回归
        task_type = 'regression'
        reason = "唯一值比例高且包含小数，判断为回归任务"
    elif n_unique <= 10 and not has_decimals:
        # 唯一值很少 + 无小数 → 分类
        task_type = 'classification'
        reason = f"唯一值数量少({n_unique}个)且无小数，判断为分类任务"
    elif n_unique == 2:
        # 只有2个唯一值 → 二分类
        task_type = 'binary_classification'
        reason = "只有2个唯一值，判断为二分类任务"
    else:
        # 需要进一步判断
        task_type = 'uncertain'
        reason = "需要结合其他信息判断（评估指标、模型类型等）"
    
    print(f"\n判断结果: {task_type}")
    print(f"判断理由: {reason}")
    print("=" * 60)
    
    return task_type

# 使用示例
# 回归任务示例
target_regression = pd.Series([0.13, 0.35, 0.30, 0.21, 0.42, 0.15, 0.28, ...])
check_task_type(target_regression)

# 分类任务示例
target_classification = pd.Series([0, 1, 0, 1, 1, 0, 1, 0, ...])
check_task_type(target_classification)
```

---

## 判断方法：从目标变量入手

### 方法 2：分析目标变量的分布

```python
import matplotlib.pyplot as plt
import seaborn as sns

def visualize_target_distribution(target_column):
    """
    可视化目标变量分布，帮助判断任务类型
    """
    fig, axes = plt.subplots(2, 2, figsize=(15, 10))
    
    # 1. 直方图
    axes[0, 0].hist(target_column, bins=50, edgecolor='black')
    axes[0, 0].set_title('目标变量分布（直方图）')
    axes[0, 0].set_xlabel('值')
    axes[0, 0].set_ylabel('频数')
    
    # 2. 箱线图
    axes[0, 1].boxplot(target_column)
    axes[0, 1].set_title('目标变量分布（箱线图）')
    axes[0, 1].set_ylabel('值')
    
    # 3. 唯一值计数
    value_counts = target_column.value_counts()
    if len(value_counts) <= 20:
        axes[1, 0].bar(range(len(value_counts)), value_counts.values)
        axes[1, 0].set_title('唯一值频数（前20个）')
        axes[1, 0].set_xlabel('唯一值索引')
        axes[1, 0].set_ylabel('频数')
    else:
        axes[1, 0].text(0.5, 0.5, f'唯一值太多({len(value_counts)}个)\n可能是回归任务',
                       ha='center', va='center', fontsize=14)
    
    # 4. 累积分布
    sorted_values = np.sort(target_column)
    cumulative = np.arange(1, len(sorted_values) + 1) / len(sorted_values)
    axes[1, 1].plot(sorted_values, cumulative)
    axes[1, 1].set_title('累积分布函数')
    axes[1, 1].set_xlabel('值')
    axes[1, 1].set_ylabel('累积概率')
    axes[1, 1].grid(True)
    
    plt.tight_layout()
    plt.show()
    
    # 判断提示
    n_unique = target_column.nunique()
    n_total = len(target_column)
    
    if n_unique / n_total > 0.5:
        print("📊 判断提示：唯一值比例高，可能是回归任务")
    elif n_unique <= 10:
        print("📊 判断提示：唯一值数量少，可能是分类任务")
    else:
        print("📊 判断提示：需要结合其他信息判断")
```

### 判断标准

#### 回归任务的分布特征 ✅

```
直方图：连续分布，类似正态分布或均匀分布
箱线图：有连续的数据点
唯一值：数量很多（接近样本数）
累积分布：平滑的曲线
```

#### 分类任务的分布特征 ✅

```
直方图：离散的柱状图，只有几个值
箱线图：只有几个离散点
唯一值：数量很少（2-100个）
累积分布：阶梯状曲线
```

---

## 判断方法：从评估指标入手

### 方法 3：查看使用的评估指标

#### 回归任务的评估指标 ✅

```python
# 回归任务常用指标
from sklearn.metrics import (
    root_mean_squared_error,  # RMSE
    mean_squared_error,        # MSE
    mean_absolute_error,       # MAE
    r2_score,                  # R²
    mean_absolute_percentage_error  # MAPE
)

# 使用示例
rmse = root_mean_squared_error(y_true, y_pred)
mae = mean_absolute_error(y_true, y_pred)
r2 = r2_score(y_true, y_pred)
```

**特征**：
- 指标名称包含 "error"、"squared"、"mean"
- 数值越小越好（除了 R²，越大越好）
- 单位与目标变量相同

#### 分类任务的评估指标 ✅

```python
# 分类任务常用指标
from sklearn.metrics import (
    accuracy_score,      # 准确率
    precision_score,    # 精确率
    recall_score,       # 召回率
    f1_score,           # F1 分数
    roc_auc_score,      # ROC-AUC
    confusion_matrix    # 混淆矩阵
)

# 使用示例
accuracy = accuracy_score(y_true, y_pred)
precision = precision_score(y_true, y_pred)
recall = recall_score(y_true, y_pred)
f1 = f1_score(y_true, y_pred)
```

**特征**：
- 指标名称包含 "accuracy"、"precision"、"recall"、"f1"
- 数值越大越好（通常在 0-1 之间）
- 无单位（比例或概率）

### 判断代码

```python
def check_metrics(metrics_used):
    """
    根据使用的评估指标判断任务类型
    
    Args:
        metrics_used: 使用的评估指标列表或字符串
    """
    regression_metrics = [
        'rmse', 'mse', 'mae', 'r2', 'r²', 'mape',
        'root_mean_squared_error', 'mean_squared_error',
        'mean_absolute_error', 'r2_score'
    ]
    
    classification_metrics = [
        'accuracy', 'precision', 'recall', 'f1', 'f1_score',
        'roc_auc', 'auc', 'confusion_matrix',
        'accuracy_score', 'precision_score', 'recall_score'
    ]
    
    metrics_str = str(metrics_used).lower()
    
    has_regression = any(metric in metrics_str for metric in regression_metrics)
    has_classification = any(metric in metrics_str for metric in classification_metrics)
    
    if has_regression and not has_classification:
        return 'regression', '使用了回归任务的评估指标'
    elif has_classification and not has_regression:
        return 'classification', '使用了分类任务的评估指标'
    elif has_regression and has_classification:
        return 'uncertain', '同时使用了回归和分类指标，需要进一步判断'
    else:
        return 'unknown', '无法从评估指标判断'

# 使用示例
print(check_metrics('RMSE'))  # ('regression', '使用了回归任务的评估指标')
print(check_metrics('accuracy'))  # ('classification', '使用了分类任务的评估指标')
```

---

## 判断方法：从模型选择入手

### 方法 4：查看使用的模型类型

#### 回归任务的模型 ✅

```python
# 回归模型（Regressor）
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.tree import DecisionTreeRegressor
import xgboost as xgb
import lightgbm as lgb
from pytabkit import TabM_D_Regressor  # ← 当前项目使用的

# 特征：模型名称包含 "Regressor"
model = TabM_D_Regressor(...)
model = RandomForestRegressor(...)
model = xgb.XGBRegressor(...)
```

#### 分类任务的模型 ✅

```python
# 分类模型（Classifier）
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.tree import DecisionTreeClassifier
import xgboost as xgb
import lightgbm as lgb
from pytabkit import TabM_D_Classifier  # 如果存在

# 特征：模型名称包含 "Classifier"
model = RandomForestClassifier(...)
model = xgb.XGBClassifier(...)
model = LogisticRegression(...)
```

### 判断代码

```python
def check_model_type(model_name_or_class):
    """
    根据模型名称或类型判断任务类型
    
    Args:
        model_name_or_class: 模型名称（字符串）或模型类
    """
    model_str = str(model_name_or_class).lower()
    
    regression_keywords = [
        'regressor', 'regression', 'reg', '回归'
    ]
    
    classification_keywords = [
        'classifier', 'classification', 'class', '分类'
    ]
    
    has_regression = any(keyword in model_str for keyword in regression_keywords)
    has_classification = any(keyword in model_str for keyword in classification_keywords)
    
    if has_regression and not has_classification:
        return 'regression', '使用了回归模型'
    elif has_classification and not has_regression:
        return 'classification', '使用了分类模型'
    else:
        return 'uncertain', '无法从模型名称判断'

# 使用示例
print(check_model_type('TabM_D_Regressor'))  # ('regression', '使用了回归模型')
print(check_model_type('RandomForestClassifier'))  # ('classification', '使用了分类模型')
```

---

## 实际案例对比

### 案例 1：道路事故风险预测（回归任务）

```python
# 数据特征
target = [0.13, 0.35, 0.30, 0.21, 0.42, ...]  # 连续数值
n_unique = 517754  # 几乎每个样本都有不同的值
unique_ratio = 99.9%  # 唯一值比例很高

# 评估指标
metric = 'RMSE'  # 回归指标

# 模型
model = TabM_D_Regressor(...)  # 回归器

# 输出
predictions = [0.15, 0.33, 0.28, ...]  # 连续数值

# 判断：✅ 回归任务
```

### 案例 2：垃圾邮件分类（分类任务）

```python
# 数据特征
target = [0, 1, 0, 1, 1, 0, ...]  # 离散类别（0=正常，1=垃圾）
n_unique = 2  # 只有2个唯一值
unique_ratio = 0.0004%  # 唯一值比例很低

# 评估指标
metric = 'accuracy'  # 分类指标

# 模型
model = RandomForestClassifier(...)  # 分类器

# 输出
predictions = [0, 1, 0, 1, ...]  # 离散类别

# 判断：✅ 分类任务（二分类）
```

### 案例 3：房价预测（回归任务）

```python
# 数据特征
target = [500000, 750000, 320000, ...]  # 连续数值（价格）
n_unique = 10000  # 很多唯一值
unique_ratio = 50%  # 唯一值比例较高

# 评估指标
metric = 'RMSE'  # 回归指标

# 模型
model = XGBRegressor(...)  # 回归器

# 输出
predictions = [520000, 730000, 310000, ...]  # 连续数值

# 判断：✅ 回归任务
```

### 案例 4：图像分类（分类任务）

```python
# 数据特征
target = ['cat', 'dog', 'bird', 'cat', ...]  # 离散类别
n_unique = 10  # 10个类别
unique_ratio = 0.001%  # 唯一值比例很低

# 评估指标
metric = 'accuracy'  # 分类指标

# 模型
model = ResNetClassifier(...)  # 分类器

# 输出
predictions = ['cat', 'dog', 'bird', ...]  # 离散类别

# 判断：✅ 分类任务（多分类）
```

---

## 判断流程图

```
开始
  │
  ├─ 查看目标变量
  │   │
  │   ├─ 是连续数值？
  │   │   ├─ 是 → 可能是回归 ✅
  │   │   └─ 否 → 继续判断
  │   │
  │   ├─ 唯一值数量？
  │   │   ├─ 很多（>50%样本） → 可能是回归 ✅
  │   │   ├─ 很少（2-100个） → 可能是分类 ✅
  │   │   └─ 中等 → 继续判断
  │   │
  │   └─ 是否有小数？
  │       ├─ 是 → 可能是回归 ✅
  │       └─ 否 → 可能是分类 ✅
  │
  ├─ 查看评估指标
  │   │
  │   ├─ 使用 RMSE/MAE/MSE？
  │   │   └─ 是 → 回归任务 ✅
  │   │
  │   └─ 使用 Accuracy/Precision/Recall？
  │       └─ 是 → 分类任务 ✅
  │
  ├─ 查看模型类型
  │   │
  │   ├─ 模型名称包含 "Regressor"？
  │   │   └─ 是 → 回归任务 ✅
  │   │
  │   └─ 模型名称包含 "Classifier"？
  │       └─ 是 → 分类任务 ✅
  │
  └─ 综合判断
      │
      ├─ 多个证据指向回归 → 回归任务 ✅
      ├─ 多个证据指向分类 → 分类任务 ✅
      └─ 证据矛盾 → 需要进一步分析
```

---

## 特殊情况处理

### 情况 1：目标变量是整数，但范围很大

```python
# 示例：预测年龄（0-100岁）
target = [25, 30, 45, 60, 35, ...]  # 整数，但范围大

# 判断：
# - 虽然是无小数，但唯一值很多
# - 数值是连续的（0-100）
# - 通常使用回归指标（RMSE）
# → 这是回归任务 ✅
```

### 情况 2：目标变量是 0-1 之间的数值

```python
# 示例：预测概率或风险值
target = [0.13, 0.35, 0.30, ...]  # 0-1之间的连续值

# 判断：
# - 有小数部分
# - 唯一值很多
# - 使用回归指标
# → 这是回归任务 ✅

# 注意：不要与二分类混淆
# 二分类：输出是 0 或 1（只有2个值）
# 回归：输出是 0-1 之间的任意值（连续）
```

### 情况 3：多标签分类 vs 多输出回归

```python
# 多标签分类：每个样本有多个类别标签
target = [[0, 1, 0], [1, 0, 1], ...]  # 多个二分类

# 多输出回归：每个样本有多个连续值
target = [[0.3, 0.5, 0.2], [0.4, 0.6, 0.1], ...]  # 多个连续值

# 判断：
# - 看每个输出的性质（离散 vs 连续）
# - 看使用的评估指标
```

### 情况 4：序数回归（Ordinal Regression）

```python
# 示例：评分预测（1-5星）
target = [1, 2, 3, 4, 5]  # 离散但有序

# 判断：
# - 可以使用回归方法（将评分视为连续值）
# - 也可以使用分类方法（将评分视为类别）
# - 通常根据评估指标和模型选择判断
```

---

## 完整判断函数

```python
def determine_task_type(data_path=None, target_column=None, 
                        metrics_used=None, model_name=None):
    """
    综合判断任务类型（回归 vs 分类）
    
    Args:
        data_path: 数据文件路径
        target_column: 目标变量（Series 或列名）
        metrics_used: 使用的评估指标（字符串或列表）
        model_name: 使用的模型名称（字符串）
    
    Returns:
        task_type: 'regression', 'classification', 'binary_classification', 'uncertain'
        confidence: 置信度（0-1）
        reasons: 判断理由列表
    """
    reasons = []
    scores = {'regression': 0, 'classification': 0}
    
    # 1. 从目标变量判断
    if target_column is not None:
        if isinstance(target_column, str) and data_path:
            # 如果是列名，从数据文件读取
            import pandas as pd
            df = pd.read_csv(data_path)
            target_column = df[target_column]
        
        n_unique = target_column.nunique()
        n_total = len(target_column)
        unique_ratio = n_unique / n_total
        
        if target_column.dtype in ['float64', 'float32']:
            has_decimals = (target_column % 1 != 0).any()
        else:
            has_decimals = False
        
        if unique_ratio > 0.5 and has_decimals:
            scores['regression'] += 3
            reasons.append(f"目标变量唯一值比例高({unique_ratio:.1%})且包含小数")
        elif n_unique == 2:
            scores['classification'] += 3
            reasons.append("目标变量只有2个唯一值（二分类）")
        elif n_unique <= 10 and not has_decimals:
            scores['classification'] += 2
            reasons.append(f"目标变量唯一值数量少({n_unique}个)且无小数")
        elif unique_ratio > 0.3:
            scores['regression'] += 1
            reasons.append(f"目标变量唯一值比例较高({unique_ratio:.1%})")
    
    # 2. 从评估指标判断
    if metrics_used:
        metrics_str = str(metrics_used).lower()
        regression_metrics = ['rmse', 'mse', 'mae', 'r2', 'r²', 'mape']
        classification_metrics = ['accuracy', 'precision', 'recall', 'f1', 'roc_auc', 'auc']
        
        if any(m in metrics_str for m in regression_metrics):
            scores['regression'] += 2
            reasons.append("使用了回归任务的评估指标")
        if any(m in metrics_str for m in classification_metrics):
            scores['classification'] += 2
            reasons.append("使用了分类任务的评估指标")
    
    # 3. 从模型类型判断
    if model_name:
        model_str = str(model_name).lower()
        if 'regressor' in model_str or 'regression' in model_str:
            scores['regression'] += 2
            reasons.append("使用了回归模型")
        if 'classifier' in model_str or 'classification' in model_str:
            scores['classification'] += 2
            reasons.append("使用了分类模型")
    
    # 综合判断
    if scores['regression'] > scores['classification']:
        task_type = 'regression'
        confidence = scores['regression'] / (scores['regression'] + scores['classification'] + 1)
    elif scores['classification'] > scores['regression']:
        if scores['classification'] >= 3 and '二分类' in str(reasons):
            task_type = 'binary_classification'
        else:
            task_type = 'classification'
        confidence = scores['classification'] / (scores['regression'] + scores['classification'] + 1)
    else:
        task_type = 'uncertain'
        confidence = 0.5
        reasons.append("证据不足，需要更多信息")
    
    return task_type, confidence, reasons

# 使用示例
# 示例 1：回归任务
task_type, confidence, reasons = determine_task_type(
    data_path='train.csv',
    target_column='accident_risk',
    metrics_used='RMSE',
    model_name='TabM_D_Regressor'
)
print(f"任务类型: {task_type}")
print(f"置信度: {confidence:.2%}")
print(f"判断理由: {reasons}")

# 输出：
# 任务类型: regression
# 置信度: 87.50%
# 判断理由: ['目标变量唯一值比例高(99.9%)且包含小数', '使用了回归任务的评估指标', '使用了回归模型']
```

---

## 总结

### 判断回归任务的标志 ✅

1. **目标变量**：
   - 连续数值（有小数部分）
   - 唯一值数量很多（>50%样本）
   - 数值范围连续

2. **评估指标**：
   - RMSE, MAE, MSE, R²

3. **模型类型**：
   - Regressor（回归器）

4. **输出格式**：
   - 连续数值

### 判断分类任务的标志 ✅

1. **目标变量**：
   - 离散类别（整数或字符串）
   - 唯一值数量很少（2-100个）
   - 无小数部分

2. **评估指标**：
   - Accuracy, Precision, Recall, F1, ROC-AUC

3. **模型类型**：
   - Classifier（分类器）

4. **输出格式**：
   - 类别标签

### 判断流程建议

1. **第一步**：查看目标变量的数据类型和分布
2. **第二步**：检查使用的评估指标
3. **第三步**：查看模型类型
4. **第四步**：综合判断

### 遇到新问题时的判断步骤

```
1. 加载数据，查看目标变量
   ├─ 数据类型是什么？
   ├─ 唯一值有多少？
   └─ 是否有小数部分？

2. 查看问题描述或代码
   ├─ 使用什么评估指标？
   └─ 使用什么模型？

3. 综合判断
   └─ 多个证据是否一致？
```

---

## 参考资料

- **sklearn 文档**：模型选择指南
- **机器学习基础**：回归 vs 分类
- **Kaggle 竞赛**：问题类型判断

