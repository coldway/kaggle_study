# 本地运行替代方案

## 问题说明

`%%python --bg` 是 Kaggle 特定的魔法命令，在本地 Jupyter 环境中不支持。这导致 `train_proc0`, `train_proc1`, `infer_proc0`, `infer_proc1` 变量无法创建。

## 解决方案

### 方案 1: 顺序执行（推荐，适合单 GPU）

修改 notebook，将后台进程改为顺序执行：

**替换 Cell 8-11**（原来的 `%%python --bg` 单元格）：

```python
# Cell 8: 训练 GPU 0
from common_stuff import *
start_training(gpu=0)
```

```python
# Cell 9: 训练 GPU 1（如果有多 GPU）
# 如果只有单 GPU，跳过这个单元格或设置 multi_gpu_train = False
from common_stuff import *
if multi_gpu_train:
    start_training(gpu=1)
```

```python
# Cell 10: 推理 GPU 0
from common_stuff import *
start_inference(gpu=0)
```

```python
# Cell 11: 推理 GPU 1（如果有多 GPU）
from common_stuff import *
if multi_gpu_train:
    start_inference(gpu=1)
```

**替换 Cell 12**（等待进程的单元格）：

```python
# 顺序执行不需要等待，直接生成提交文件
from common_stuff import *
import json

# 加载解码器和生成提交
decoder = Decoder(formatter, arc_test_set.split_multi_replies(), n_guesses=2, prob_baseline=0.05)
submission = arc_test_set.get_submission(decoder.run_selection_algo(submission_select_algo))
with open('submission.json', 'w') as f:
    json.dump(submission, f)

if arc_test_set.is_fake:
    decoder.benchmark_selection_algos(selection_algorithms)
    with open('submission.json') as f:
        reload_submission = json.load(f)
    print('*** Reload score:', arc_test_set.validate_submission(reload_submission))
```

### 方案 2: 使用 threading（适合多 GPU）

如果需要并行执行，可以使用 Python 的 threading：

```python
import threading
from common_stuff import *

# 创建线程
train_thread_0 = threading.Thread(target=start_training, args=(0,))
train_thread_1 = threading.Thread(target=start_training, args=(1,)) if multi_gpu_train else None
infer_thread_0 = threading.Thread(target=start_inference, args=(0,))
infer_thread_1 = threading.Thread(target=start_inference, args=(1,)) if multi_gpu_train else None

# 启动训练线程
train_thread_0.start()
if train_thread_1:
    train_thread_1.start()

# 等待训练完成
train_thread_0.join()
if train_thread_1:
    train_thread_1.join()

# 启动推理线程
infer_thread_0.start()
if infer_thread_1:
    infer_thread_1.start()

# 等待推理完成
infer_thread_0.join()
if infer_thread_1:
    infer_thread_1.join()

print('*** All processes completed')
```

### 方案 3: 使用 multiprocessing（适合多 GPU，更稳定）

```python
from multiprocessing import Process
from common_stuff import *
import time

# 创建进程
processes = [
    Process(target=start_training, args=(0,)),
]

if multi_gpu_train:
    processes.append(Process(target=start_training, args=(1,)))

# 启动训练进程
for p in processes:
    p.start()

# 等待训练完成
for p in processes:
    p.join()

# 创建推理进程
infer_processes = [
    Process(target=start_inference, args=(0,)),
]

if multi_gpu_train:
    infer_processes.append(Process(target=start_inference, args=(1,)))

# 启动推理进程
for p in infer_processes:
    p.start()

# 等待推理完成
for p in infer_processes:
    p.join()

print('*** All processes completed')
```

## 单 GPU 配置

如果只有单 GPU，需要修改 `common_stuff.py`：

```python
# 在 common_stuff.py 中修改
multi_gpu_train = False  # 改为 False
```

然后只运行：
- Cell 8: `start_training(gpu=0)`
- Cell 10: `start_inference(gpu=0)`

## 快速修复步骤

1. **打开 notebook**

2. **找到 Cell 8-11**（使用 `%%python --bg` 的单元格）

3. **替换为顺序执行代码**（见方案 1）

4. **删除或修改 Cell 12**（等待进程的单元格）

5. **运行修改后的单元格**

## 注意事项

1. **GPU 内存**：确保有足够的 GPU 内存
2. **执行时间**：顺序执行会比并行执行慢
3. **错误处理**：如果某个步骤失败，后续步骤不会执行

## 推荐配置

对于本地运行，推荐使用**方案 1（顺序执行）**，因为：
- 简单易懂
- 不需要处理进程间通信
- 错误更容易调试
- 适合单 GPU 环境

